[
    {
        "sample_order": 23,
        "operator": "e1",
        "score": -366787.14285714284,
        "algorithm": "The improved approach restructures the acceptance criterion to rely on a modular event-driven system that emphasizes real-time adjustments of dynamic parameters, enhancing exploration of the solution space in CVRP.",
        "function": "package DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\n\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    private double thresholdOF;\n    private double eta, etaMin, etaMax; // Dynamic adjustment parameters\n    private long startTime; // Track execution time\n    private double alpha = 1; // Influence factor for eta\n    private int globalIterator = 0; // Count of total iterations\n    private final StoppingCriterionType stoppingCriterionType; // Type of stopping criterion\n    private final double executionMaximumLimit; // Max execution time\n    private final int updateFrequency; // Frequency for updating alpha\n    private double upperLimit, updatedUpperLimit; // Fitness limits for acceptance\n    private final Mean averageFitness; // Moving average of fitness\n    private final ThreadMXBean threadMXBean; // For efficient time tracking\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaximumLimit) {\n        this.etaMax = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.eta = this.etaMax; // Initialize eta to max\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageFitness = new Mean(config.getGamma());\n        this.updateFrequency = config.getGamma();\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean();\n        this.upperLimit = Double.MAX_VALUE; // Initialize to maximum value\n        this.updatedUpperLimit = Double.MAX_VALUE; // Also set updated upper limit\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        if (globalIterator == 0) {\n            startTime = System.nanoTime(); // Start time for the first solution\n        }\n\n        // Update fitness with the incoming solution\n        averageFitness.setValue(solution.f);\n        globalIterator++;\n\n        // Update the limits based on the solution's fitness\n        updateLimits(solution.f);\n\n        // Check if it's time to update alpha and possibly eta\n        if (isUpdateIteration()) {\n            adjustAlphaAndEta();\n        }\n\n        // Calculate the acceptance threshold\n        thresholdOF = calculateThreshold();\n        return solution.f <= thresholdOF; // Accept solution if below threshold\n    }\n\n    private void updateLimits(double fitness) {\n        // Update current best fitness values\n        if (fitness < updatedUpperLimit) {\n            updatedUpperLimit = fitness; // Update updated version\n        }\n        \n        if (fitness < upperLimit) {\n            upperLimit = fitness; // Update overall best\n        }\n    }\n\n    private boolean isUpdateIteration() {\n        // Check if the current iteration is a multiple of the update frequency\n        return globalIterator % updateFrequency == 0;\n    }\n\n    private void adjustAlphaAndEta() {\n        // Recalculate the alpha based on the stopping criterion type\n        double currentTime = (System.nanoTime() - startTime) / 1_000_000_000.0; // Convert to seconds\n\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = Math.pow(etaMin / etaMax, 1.0 / executionMaximumLimit);\n                break;\n            case Time:\n                double totalIterations = (globalIterator == 0) ? 1 : globalIterator;\n                alpha = Math.pow(etaMin / etaMax, 1.0 / (currentTime < 1 ? 1 : currentTime));\n                break;\n        }\n\n        eta = Math.max(etaMin, eta * alpha); // Update eta, ensuring it doesn't fall below minimum\n\n        // Reset upper limit after update\n        upperLimit = updatedUpperLimit; \n        updatedUpperLimit = Double.MAX_VALUE; // Prepare for next cycle\n    }\n\n    private double calculateThreshold() {\n        // Compute the threshold for acceptance with current upper limit and average\n        return upperLimit + (eta * (averageFitness.getDynamicAverage() - upperLimit));\n    }\n\n    public double getEta() {\n        return eta; // Return current eta value\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF; // Return the threshold for fitness acceptance\n    }\n\n    public void setEta(double eta) {\n        this.eta = Math.max(etaMin, Math.min(eta, etaMax)); // Ensure eta remains within bounds\n    }\n}",
    },
    {
        "score": -366878.85714285716,
        "operator": "",
        "algorithm": "",
        "function": "\npackage DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    double thresholdOF;\n    double eta, etaMin, etaMax;\n    long ini;\n    double alpha = 1;\n    int globalIterator = 0;\n    StoppingCriterionType stoppingCriterionType;\n    double executionMaximumLimit;\n    int numIterUpdate;\n    double upperLimit = Integer.MAX_VALUE, updatedUpperLimit = Integer.MAX_VALUE;\n    Mean averageLSfunction;\n    ThreadMXBean threadMXBean;\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaximumLimit) {\n        this.eta = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.etaMax = config.getEtaMax();\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageLSfunction = new Mean(config.getGamma());\n        this.numIterUpdate = config.getGamma();\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean(); //\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        if (globalIterator == 0) {\n            ini = System.nanoTime(); //\n        }\n\n        averageLSfunction.setValue(solution.f);\n\n        globalIterator++;\n\n        if (globalIterator % numIterUpdate == 0) {\n            upperLimit = updatedUpperLimit;\n            updatedUpperLimit = Integer.MAX_VALUE;\n        }\n\n        if (solution.f < updatedUpperLimit) {\n            updatedUpperLimit = solution.f;\n        }\n\n        if (solution.f < upperLimit) {\n            upperLimit = solution.f;\n        }\n\n        // --------------------------------------------\n        switch (stoppingCriterionType) {\n            case Iteration:\n                if (globalIterator % numIterUpdate == 0) {\n                    alpha = Math.pow(etaMin / etaMax, (double) 1 / executionMaximumLimit);\n                }\n                break;\n\n            case Time:\n                if (globalIterator % numIterUpdate == 0) {\n                    double maxTime = executionMaximumLimit;\n                    double current = (double) (System.nanoTime() - ini) / 1_000_000_000; // \u8f6c\u6362\u4e3a\u79d2\n                    double timePercentage = current / maxTime;\n                    double total = (double) globalIterator / timePercentage;\n\n                    alpha = Math.pow(etaMin / etaMax, (double) 1 / total);\n                }\n                break;\n\n            default:\n                break;\n        }\n\n        eta *= alpha;\n        eta = Math.max(eta, etaMin);\n\n        thresholdOF = (int) (upperLimit + (eta * (averageLSfunction.getDynamicAverage() - upperLimit)));\n        if (solution.f <= thresholdOF) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public double getEta() {\n        return eta;\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF;\n    }\n\n    public void setEta(double eta) {\n        this.eta = eta;\n    }\n\n}\n"
    },
    {
        "score": -367205.4285714286,
        "operator": "init",
        "algorithm": "The improved approach emphasizes clarity, modularity, and performance optimization to enhance the acceptance criterion's efficiency and maintainability while retaining its core functionality.",
        "function": "package DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    private double thresholdOF;\n    private double eta, etaMin, etaMax;\n    private long startTime;\n    private double alpha = 1;\n    private int globalIterator = 0;\n    private StoppingCriterionType stoppingCriterionType;\n    private double executionMaximumLimit;\n    private int numIterUpdate;\n    private double upperLimit = Double.MAX_VALUE, updatedUpperLimit = Double.MAX_VALUE;\n    private Mean averageLSfunction;\n    private ThreadMXBean threadMXBean;\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaximumLimit) {\n        this.eta = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.etaMax = config.getEtaMax();\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageLSfunction = new Mean(config.getGamma());\n        this.numIterUpdate = config.getGamma();\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean(); \n        this.startTime = System.nanoTime(); // Initialize the start time in constructor\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        averageLSfunction.setValue(solution.f); // Update the moving average with the new solution's fitness\n        globalIterator++;\n\n        updateBounds(solution.f);\n\n        // Update alpha based on the stopping criterion type\n        if (globalIterator % numIterUpdate == 0) {\n            alpha = calculateAlpha(); \n        }\n\n        eta *= alpha; // Update eta based on calculated alpha\n        eta = Math.max(eta, etaMin); // Ensure eta does not drop below its minimum\n\n        // Calculate the threshold for acceptance\n        thresholdOF = calculateThreshold();\n        return solution.f <= thresholdOF; // Return true if the solution is accepted\n    }\n\n    private void updateBounds(double fitness) {\n        // Update upper and updated upper limits based on new fitness\n        if (fitness < updatedUpperLimit) {\n            updatedUpperLimit = fitness;\n        }\n\n        if (fitness < upperLimit) {\n            upperLimit = fitness;\n        }\n\n        // Reset updated upper limit for the next interval\n        if (globalIterator % numIterUpdate == 0) {\n            upperLimit = updatedUpperLimit;\n            updatedUpperLimit = Double.MAX_VALUE;\n        }\n    }\n\n    private double calculateAlpha() {\n        double currentTime = (double) (System.nanoTime() - startTime) / 1_000_000_000; // Convert to seconds\n        double totalIterations = (double) globalIterator / currentTime; // Total iterations per second\n        switch (stoppingCriterionType) {\n            case Iteration:\n                return Math.pow(etaMin / etaMax, 1.0 / executionMaximumLimit);\n            case Time:\n                return Math.pow(etaMin / etaMax, 1.0 / totalIterations);\n            default:\n                return 1; // Default case, ideally should not occur\n        }\n    }\n\n    private double calculateThreshold() {\n        return upperLimit + (eta * (averageLSfunction.getDynamicAverage() - upperLimit)); // Calculate the updated threshold\n    }\n\n    public double getEta() {\n        return eta; // Getter for eta\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF; // Getter for threshold of fitness\n    }\n\n    public void setEta(double eta) {\n        this.eta = eta; // Setter for eta\n    }\n}"
    },
    {
        "score": -367210.5714285714,
        "operator": "e2",
        "algorithm": "The acceptance criterion uses an adaptive mechanism to adjust parameters in response to the quality of new solutions while maintaining clear separation of logic to enhance maintainability and readability.",
        "function": "package DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    private double thresholdOF;\n    private double eta, etaMin, etaMax;\n    private long initTime;\n    private double alpha = 1;\n    private int globalIteration = 0;\n    private StoppingCriterionType stoppingCriterionType;\n    private double executionMaxLimit;\n    private int updateFrequency;\n    private double upperBound = Double.MAX_VALUE;\n    private double updatedUpperBound = Double.MAX_VALUE;\n    private Mean averageLSfunction;\n    private ThreadMXBean threadMXBean;\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaxLimit) {\n        this.eta = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.etaMax = config.getEtaMax();\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageLSfunction = new Mean(config.getGamma());\n        this.updateFrequency = config.getGamma();\n        this.executionMaxLimit = executionMaxLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean();\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        recordInitialTime();\n        updateAverageFunction(solution);\n        globalIteration++;\n        updateBounds(solution);\n        adjustAlpha();\n        eta = Math.max(eta * alpha, etaMin);\n        thresholdOF = computeThresholdOF();\n        return isSolutionAccepted(solution);\n    }\n\n    private void recordInitialTime() {\n        if (globalIteration == 1) {\n            initTime = System.nanoTime();\n        }\n    }\n\n    private void updateAverageFunction(Solution solution) {\n        averageLSfunction.setValue(solution.f); // Update cumulative average of objective function\n    }\n\n    private void updateBounds(Solution solution) {\n        if (solution.f < updatedUpperBound) {\n            updatedUpperBound = solution.f; // Found a new better solution\n        }\n        if (solution.f < upperBound) {\n            upperBound = solution.f; // Update upper bound if the new solution is better\n        }\n        if (globalIteration % updateFrequency == 0) {\n            resetBounds();\n        }\n    }\n\n    private void resetBounds() {\n        upperBound = updatedUpperBound; // Reset upper bound\n        updatedUpperBound = Double.MAX_VALUE; // Reset the updated upper bound\n    }\n\n    private void adjustAlpha() {\n        if (globalIteration % updateFrequency == 0) {\n            switch (stoppingCriterionType) {\n                case Iteration:\n                    alpha = computeAlphaForIteration();\n                    break;\n                case Time:\n                    alpha = computeAlphaForTimeCriterion();\n                    break;\n            }\n        }\n    }\n\n    private double computeAlphaForIteration() {\n        return Math.pow(etaMin / etaMax, 1.0 / executionMaxLimit);\n    }\n\n    private double computeAlphaForTimeCriterion() {\n        double elapsedTime = (System.nanoTime() - initTime) / 1_000_000_000.0; // Convert to seconds\n        double timeFraction = elapsedTime / executionMaxLimit;\n        return Math.pow(etaMin / etaMax, (double) globalIteration / timeFraction);\n    }\n\n    private double computeThresholdOF() {\n        return upperBound + (eta * (averageLSfunction.getDynamicAverage() - upperBound)); // Compute adaptive threshold\n    }\n\n    private boolean isSolutionAccepted(Solution solution) {\n        return solution.f <= thresholdOF; // Determine if the solution is accepted\n    }\n\n    public double getEta() {\n        return eta; // Getter for eta\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF; // Getter for threshold OF\n    }\n\n    public void setEta(double eta) {\n        this.eta = eta; // Setter for eta\n    }\n}"
    },
    {
        "score": -367623.14285714284,
        "operator": "e1",
        "algorithm": "My improved approach focuses on enhancing modular design and leveraging clear method responsibilities to streamline the acceptance criterion workflow while improving adaptability to varying solution quality metrics.",
        "function": "package DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    private double thresholdOF;\n    private double eta, etaMin, etaMax;\n    private long startTime;\n    private double alpha = 1;\n    private int globalIterator = 0;\n    private final StoppingCriterionType stoppingCriterionType;\n    private final double executionMaximumLimit;\n    private final int numIterUpdate;\n    private double upperLimit = Double.MAX_VALUE, updatedUpperLimit = Double.MAX_VALUE;\n    private final Mean averageLSfunction;\n    private final ThreadMXBean threadMXBean;\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaximumLimit) {\n        this.etaMax = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.eta = etaMax; // Start with the maximum eta value\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageLSfunction = new Mean(config.getGamma());\n        this.numIterUpdate = config.getGamma();\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean();\n        this.startTime = System.nanoTime(); // Track start time for calculations\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        updateAverageSolutionFitness(solution.f); // Update fitness moving average\n        globalIterator++;\n\n        updateBounds(solution.f); // Update upper limit bounds\n\n        if (isUpdateIteration()) {\n            alpha = calculateAlpha(); // Update alpha based on stopping criteria\n            resetUpperLimit(); // Resetting the upper limit for the current interval\n        }\n\n        eta = adjustEta(); // Adjust eta to be within limits\n        thresholdOF = calculateThreshold(); // Calculate the threshold for acceptance\n\n        return isSolutionAccepted(solution.f); // Determine if the new solution is acceptable\n    }\n\n    private void updateAverageSolutionFitness(double fitness) {\n        averageLSfunction.setValue(fitness); // Update the moving average with new solution's fitness\n    }\n\n    private void updateBounds(double fitness) {\n        if (fitness < updatedUpperLimit) {\n            updatedUpperLimit = fitness; // Update updated upper limit\n        }\n        if (fitness < upperLimit) {\n            upperLimit = fitness; // Update upper limit\n        }\n    }\n\n    private boolean isUpdateIteration() {\n        return globalIterator % numIterUpdate == 0; // Check if it's time to update alpha\n    }\n\n    private double calculateAlpha() {\n        double currentTime = (double) (System.nanoTime() - startTime) / 1_000_000_000; // Current elapsed time in seconds\n\n        switch (stoppingCriterionType) {\n            case Iteration:\n                return Math.pow(etaMin / etaMax, 1.0 / executionMaximumLimit);\n            case Time:\n                double totalIterations = (double) globalIterator / currentTime; // Calculate iterations per elapsed time\n                return Math.pow(etaMin / etaMax, 1.0 / totalIterations);\n            default:\n                return 1; // Fallback default for safety\n        }\n    }\n\n    private void resetUpperLimit() {\n        upperLimit = updatedUpperLimit; // Update upper limit for current state\n        updatedUpperLimit = Double.MAX_VALUE; // Reset for next phase\n    }\n\n    private double adjustEta() {\n        eta *= alpha; // Adjust eta based on alpha\n        return Math.max(eta, etaMin); // Ensure eta doesn't drop below minimum\n    }\n\n    private double calculateThreshold() {\n        return upperLimit + (eta * (averageLSfunction.getDynamicAverage() - upperLimit)); // Compute threshold for acceptance\n    }\n\n    private boolean isSolutionAccepted(double fitness) {\n        return fitness <= thresholdOF; // Check if the solution meets acceptance criteria\n    }\n\n    public double getEta() {\n        return eta; // Getter for current eta value\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF; // Getter for threshold of fitness\n    }\n\n    public void setEta(double eta) {\n        this.eta = eta; // Setter for eta value\n    }\n}"
    },
    {
        "score": -367880.14285714284,
        "operator": "init",
        "algorithm": "The improved approach refactors the acceptance criterion methods for better readability, performance, and management of parameters to enhance solution acceptance in CVRP using more concise and efficient calculations.",
        "function": "package DiversityControl;\n\nimport Auxiliary.Mean;\nimport Data.Instance;\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\nimport Solution.Solution;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class AcceptanceCriterion {\n    private double thresholdOF;\n    private double eta, etaMin, etaMax;\n    private long startTime;\n    private double alpha = 1;\n    private int globalIterator = 0;\n    private final StoppingCriterionType stoppingCriterionType;\n    private final double executionMaximumLimit;\n    private final int numIterUpdate;\n    private double upperLimit = Integer.MAX_VALUE, updatedUpperLimit = Integer.MAX_VALUE;\n    private final Mean averageLSfunction;\n    private final ThreadMXBean threadMXBean;\n\n    public AcceptanceCriterion(Instance instance, Config config, Double executionMaximumLimit) {\n        this.etaMax = config.getEtaMax();\n        this.etaMin = config.getEtaMin();\n        this.eta = etaMax; // Initialize eta to max\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.averageLSfunction = new Mean(config.getGamma());\n        this.numIterUpdate = config.getGamma();\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.threadMXBean = ManagementFactory.getThreadMXBean();\n    }\n\n    public boolean acceptSolution(Solution solution) {\n        if (globalIterator == 0) {\n            startTime = System.nanoTime();\n        }\n\n        averageLSfunction.setValue(solution.f);\n        globalIterator++;\n\n        updateLimits(solution);\n\n        if (isUpdateIteration()) {\n            updateAlpha();\n        }\n\n        eta = Math.max(etaMin, eta * alpha);\n        thresholdOF = computeThresholdOF();\n\n        return solution.f <= thresholdOF;\n    }\n\n    private void updateLimits(Solution solution) {\n        if (solution.f < updatedUpperLimit) {\n            updatedUpperLimit = solution.f;\n        }\n        if (solution.f < upperLimit) {\n            upperLimit = solution.f;\n        }\n    }\n\n    private boolean isUpdateIteration() {\n        return globalIterator % numIterUpdate == 0;\n    }\n\n    private void updateAlpha() {\n        if (stoppingCriterionType == StoppingCriterionType.Iteration) {\n            alpha = Math.pow(etaMin / etaMax, 1.0 / executionMaximumLimit);\n        } else if (stoppingCriterionType == StoppingCriterionType.Time) {\n            double currentTime = (double) (System.nanoTime() - startTime) / 1_000_000_000; // Time in seconds\n            double timePercentage = currentTime / executionMaximumLimit;\n            double totalIterations = (double) globalIterator / timePercentage;\n            alpha = Math.pow(etaMin / etaMax, 1.0 / totalIterations);\n        }\n        // Reset upper limit after updates\n        if (isUpdateIteration()) {\n            upperLimit = updatedUpperLimit;\n            updatedUpperLimit = Integer.MAX_VALUE;\n        }\n    }\n\n    private double computeThresholdOF() {\n        return upperLimit + (eta * (averageLSfunction.getDynamicAverage() - upperLimit));\n    }\n\n    public double getEta() {\n        return eta;\n    }\n\n    public double getThresholdOF() {\n        return thresholdOF;\n    }\n\n    public void setEta(double eta) {\n        this.eta = eta;\n    }\n}"
    }
]