[
    {
        "sample_order": 1,
        "score": -27591.0,
        "algorithm": "",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private final double executionMaximumLimit;\n    private double alpha = 1;\n    private final StoppingCriterionType stoppingCriterionType;\n    private final IdealDist idealDist;\n\n    // DecayFunction interface for adaptive decay schedules\n    interface DecayFunction {\n        double calculateAlpha(int currentIteration, double executionLimit);\n    }\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) {\n            ini = System.currentTimeMillis();\n        }\n\n        iterator++;\n\n        // Calls the appropriate adjustment based on stoppingCriterionType\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = iterationAdjustment();\n                break;\n            case Time:\n                alpha = timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Apply the decay factor and clamp the ideal distance\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Method for iterative adjustment with flexible decay\n    private double iterationAdjustment() {\n        return computeDecayAlpha(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n\n    // Method for time-based adjustment with flexible decay\n    private double timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        return computeDecayAlpha(distMMin, distMMax, total, 1); // Adapted for time\n    }\n\n    // General method to compute decay alpha for flexibility\n    private double computeDecayAlpha(int dMin, int dMax, double limit, double param) {\n        // Using a piecewise function for nonlinear decay (can be modified to suit needs)\n        if (param < limit) { // Early phase\n            return Math.pow((double) dMin / (double) dMax, 1 / (limit - param + 1)); // Smoother transition\n        } else { // Late phase\n            return 1.0; // Maintain stability\n        }\n    }\n}"
    },
    {
        "sample_order": 2,
        "score": -27591.0,
        "algorithm": "The improved approach introduces nonlinear decay schedules for adjusting diversity distance, enhancing numerical stability, and offering flexibility in the adjustment mechanism.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment \n{\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private double executionMaximumLimit;\n    private double alpha = 1;\n    private StoppingCriterionType stoppingCriterionType;\n    private IdealDist idealDist;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) \n    {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax; // Start at maximum diversity distance\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() \n    {\n        if (iterator == 0)\n            ini = System.currentTimeMillis();\n\n        iterator++;\n        \n        // Adjust distance based on configured stopping criterion\n        switch (stoppingCriterionType) \n        {\n            case Iteration: \n                iterationAdjustment(); \n                break;\n            case Time: \n                timeAdjustment(); \n                break;\n            default:\n                break;       \n        }\n        \n        // Apply the adjustment factor and clamp the ideal distance within boundaries\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n    \n    private void iterationAdjustment() \n    {\n        alpha = computeDecayFactor(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n    \n    private void timeAdjustment() \n    {\n        double current = (double)(System.currentTimeMillis() - ini) / 1000; // Convert from milliseconds to seconds\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double)iterator / timePercentage;\n        alpha = computeDecayFactor(distMMin, distMMax, total, iterator);\n    }\n\n    private double computeDecayFactor(int min, int max, double total, int iter) \n    {\n        // Here we use an exponential decay strategy to adjust alpha more smoothly\n        // This can be adapted to different decay schedules as needed\n        double normalizedDecay = (double)(min) / (double)(max);\n        return Math.pow(normalizedDecay, 1.0 / Math.max(total, 1)); // Prevent division by zero\n    }\n\n    // Optional: You could create additional methods for other decay functions like cosine or piecewise if required\n}"
    },
    {
        "sample_order": 3,
        "score": -27591.0,
        "algorithm": "I propose enhancing the `DistAdjustment` class by implementing flexible decay schedules through a strategy pattern and improving numerical stability with smooth transition functions that allow for adaptive adjustments for both exploration and exploitation phases.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    int distMMin;\n    int distMMax;\n    int iterator;\n    long ini;\n    double executionMaximumLimit;\n    double alpha = 1;\n    StoppingCriterionType stoppingCriterionType;\n    IdealDist idealDist;\n    DistanceDecayStrategy decayStrategy;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.decayStrategy = new ExponentialDecay(); // Default decay strategy\n    }\n\n    public void setDecayStrategy(DistanceDecayStrategy decayStrategy) {\n        this.decayStrategy = decayStrategy;\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) ini = System.currentTimeMillis();\n        iterator++;\n\n        adjustmentBasedOnCriterion();\n        \n        // Update idealDist based on the alpha value\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    private void adjustmentBasedOnCriterion() {\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = decayStrategy.calculateAlpha(distMMin, distMMax, iterator, executionMaximumLimit);\n                break;\n            case Time:\n                double current = (double) (System.currentTimeMillis() - ini) / 1000;\n                double timePercentage = current / executionMaximumLimit;\n                alpha = decayStrategy.calculateAlpha(distMMin, distMMax, (int)(iterator / timePercentage), executionMaximumLimit);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\n// Strategy interface for distance decay\ninterface DistanceDecayStrategy {\n    double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit);\n}\n\n// Exponential decay implementation\nclass ExponentialDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        return Math.pow((double) distMMin / (double) distMMax, (double) 1 / executionMaximumLimit);\n    }\n}\n\n// Add more decay strategies as needed, e.g., CosineDecay, PiecewiseDecay, etc.\nclass CosineDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        double phase = (double) iterator / executionMaximumLimit;\n        return (1 + Math.cos(Math.PI * phase)) / 2; // Normalized cosine decay\n    }\n}\n\n// Implement a piecewise decay strategy as needed\nclass PiecewiseDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        // Custom piecewise decay logic based on certain criteria\n        // Placeholder for illustration\n        if (iterator < executionMaximumLimit / 2) {\n            return Math.pow(((double) distMMin / distMMax), (double) 1 / (executionMaximumLimit / 2));\n        } else {\n            return 1.0; // No decay in the latter half\n        }\n    }\n}"
    }
]