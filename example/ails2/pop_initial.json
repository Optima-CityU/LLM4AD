[
    {
        "sample_order": 1,
        "score": -27591.0,
        "algorithm": "",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private final double executionMaximumLimit;\n    private double alpha = 1;\n    private final StoppingCriterionType stoppingCriterionType;\n    private final IdealDist idealDist;\n\n    // DecayFunction interface for adaptive decay schedules\n    interface DecayFunction {\n        double calculateAlpha(int currentIteration, double executionLimit);\n    }\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) {\n            ini = System.currentTimeMillis();\n        }\n\n        iterator++;\n\n        // Calls the appropriate adjustment based on stoppingCriterionType\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = iterationAdjustment();\n                break;\n            case Time:\n                alpha = timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Apply the decay factor and clamp the ideal distance\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Method for iterative adjustment with flexible decay\n    private double iterationAdjustment() {\n        return computeDecayAlpha(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n\n    // Method for time-based adjustment with flexible decay\n    private double timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        return computeDecayAlpha(distMMin, distMMax, total, 1); // Adapted for time\n    }\n\n    // General method to compute decay alpha for flexibility\n    private double computeDecayAlpha(int dMin, int dMax, double limit, double param) {\n        // Using a piecewise function for nonlinear decay (can be modified to suit needs)\n        if (param < limit) { // Early phase\n            return Math.pow((double) dMin / (double) dMax, 1 / (limit - param + 1)); // Smoother transition\n        } else { // Late phase\n            return 1.0; // Maintain stability\n        }\n    }\n}"
    },
    {
        "sample_order": 2,
        "score": -27941.0,
        "algorithm": "",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    int distMMin;\n    int distMMax;\n    int iterator;\n    long ini;\n    double executionMaximumLimit;\n    double alpha = 1;\n    StoppingCriterionType stoppingCriterionType;\n    IdealDist idealDist;\n\n    // Define types of decay schedules for flexibility\n    public enum DecayType {\n        LINEAR,\n        EXPONENTIAL,\n        COSINE\n    }\n\n    private DecayType decayType;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.decayType = DecayType.EXPONENTIAL;  // Default decay type\n    }\n\n    // Public method to set the decay type\n    public void setDecayType(DecayType decayType) {\n        this.decayType = decayType;\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) {\n            ini = System.currentTimeMillis();\n        }\n\n        iterator++;\n\n        switch (stoppingCriterionType) {\n            case Iteration:\n                iterationAdjustment();\n                break;\n            case Time:\n                timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Apply decay calculation based on the set type\n        applyDecay();\n        \n        // Ensure idealDist remains within defined limits\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Adjust alpha based on the number of iterations\n    private void iterationAdjustment() {\n        alpha = calculateDecay(1.0 - (double) distMMax / distMMin);\n    }\n\n    // Adjust alpha based on time elapsed\n    private void timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        alpha = calculateDecay(1.0 - (double) distMMax / distMMin, total);\n    }\n    \n    // Calculate decay using the selected decay type\n    private void applyDecay() {\n        switch (decayType) {\n            case LINEAR:\n                idealDist.idealDist *= alpha;\n                break;\n            case EXPONENTIAL:\n                idealDist.idealDist *= Math.exp(-alpha);\n                break;\n            case COSINE:\n                idealDist.idealDist *= (1 - Math.cos(Math.PI * (iterator / executionMaximumLimit)));\n                break;\n        }\n    }\n\n    // Calculate the decay factor based on the selected decay type\n    private double calculateDecay(double decayRatio) {\n        return Math.pow(decayRatio, 1 / executionMaximumLimit);\n    }\n\n    // Overloaded method for decay calculation with additional parameters for flexibility\n    private double calculateDecay(double decayRatio, double factor) {\n        return Math.pow(decayRatio, 1 / factor);\n    }\n}"
    },
    {
        "sample_order": 3,
        "score": -27591.0,
        "algorithm": "I propose an improved `DistAdjustment` class that incorporates adaptive nonlinear decay schedules and ensures numerical stability during diversity adjustments while maintaining compatibility with the original functionality.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    private int distMMin;                      // Minimum diversity distance\n    private int distMMax;                      // Maximum diversity distance\n    private int iterator;                       // Iteration count\n    private long ini;                           // Initial time for calculation\n    private double executionMaximumLimit;       // Maximum execution limit\n    private double alpha = 1;                   // Decay factor\n    private StoppingCriterionType stoppingCriterionType; // Type of stopping criterion\n    private IdealDist idealDist;                // Ideal distance object\n\n    // Constructor initializing member variables\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    // Method to adjust diversity distance\n    public void distAdjustment() {\n        if (iterator == 0) ini = System.currentTimeMillis(); // Initialize time tracking\n        iterator++;\n        \n        // Adjust based on stopping criterion\n        switch (stoppingCriterionType) {\n            case Iteration:\n                iterationAdjustment(); \n                break;\n            case Time:\n                timeAdjustment(); \n                break;\n            default:\n                break;\n        }\n        \n        // Update ideal distance using decay factor while ensuring stability\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Method to adjust decay based on the number of iterations\n    private void iterationAdjustment() {\n        // Nonlinear decay using a smooth exponential function\n        alpha = computeDecayFactor(iterator, distMMin, distMMax, executionMaximumLimit);\n    }\n\n    // Method to adjust decay based on elapsed time\n    private void timeAdjustment() {\n        double current = (double)(System.currentTimeMillis() - ini) / 1000; // Current time in seconds\n        double timePercentage = current / executionMaximumLimit;\n        // Ensure to calculate decay factor based on time elapsed\n        alpha = computeDecayFactor((int)(timePercentage * executionMaximumLimit), distMMin, distMMax, executionMaximumLimit);\n    }\n    \n    // A method that computes a flexible decay factor based on given parameters\n    private double computeDecayFactor(int currentIterator, int dMin, int dMax, double execLimit) {\n        if (currentIterator <= 0) return 1; // Early return for stability\n        // Compute a decay based on exponential mapping for flexibility and nonlinear approaches\n        return Math.pow((double) dMin / (double) dMax, (double) 1 / execLimit) * \n               Math.sin(Math.PI * (currentIterator / execLimit)); // Example of cosine adjustment for nonlinearity\n    }\n}"
    },
    {
        "sample_order": 4,
        "score": -27591.0,
        "algorithm": "The improved approach focuses on enhancing numerical stability, providing flexibility for dynamic decay schedules, and implementing additional non-linear decay strategies to optimize the diversity adjustment process.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    // Minimum and maximum diversity distances\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private double executionMaximumLimit;\n    private double alpha = 1;\n    private StoppingCriterionType stoppingCriterionType;\n    private IdealDist idealDist;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax; // Start at maximum distance\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() {\n        // Initialize iterator and starting time\n        if (iterator == 0) ini = System.currentTimeMillis();\n        iterator++;\n\n        // Adjustably change distance based on the stopping criterion\n        switch (stoppingCriterionType) {\n            case Iteration:\n                iterationAdjustment();\n                break;\n            case Time:\n                timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Update the ideal distance with capped alpha adjustment for stability\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = clamp(idealDist.idealDist, distMMin, distMMax);\n    }\n\n    // Linear decay adjustment based on the iteration count\n    private void iterationAdjustment() {\n        alpha = getDecayFactor(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n\n    // Time-based decay adjustment\n    private void timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        alpha = getDecayFactor(distMMin, distMMax, total, iterator);\n    }\n\n    // Generalized method to compute the decay factor, allowing flexibility for different decay schedules\n    private double getDecayFactor(int min, int max, double decayBase, int step) {\n        return Math.pow((double) min / (double) max, (1.0 / decayBase) * step);\n    }\n\n    // Clamp method to ensure the ideal distance remains within bounds\n    private double clamp(double value, double min, double max) {\n        return Math.min(max, Math.max(value, min));\n    }\n}"
    },
    {
        "sample_order": 5,
        "score": -27591.0,
        "algorithm": "The improved approach introduces nonlinear decay schedules for adjusting diversity distance, enhancing numerical stability, and offering flexibility in the adjustment mechanism.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment \n{\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private double executionMaximumLimit;\n    private double alpha = 1;\n    private StoppingCriterionType stoppingCriterionType;\n    private IdealDist idealDist;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) \n    {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax; // Start at maximum diversity distance\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() \n    {\n        if (iterator == 0)\n            ini = System.currentTimeMillis();\n\n        iterator++;\n        \n        // Adjust distance based on configured stopping criterion\n        switch (stoppingCriterionType) \n        {\n            case Iteration: \n                iterationAdjustment(); \n                break;\n            case Time: \n                timeAdjustment(); \n                break;\n            default:\n                break;       \n        }\n        \n        // Apply the adjustment factor and clamp the ideal distance within boundaries\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n    \n    private void iterationAdjustment() \n    {\n        alpha = computeDecayFactor(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n    \n    private void timeAdjustment() \n    {\n        double current = (double)(System.currentTimeMillis() - ini) / 1000; // Convert from milliseconds to seconds\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double)iterator / timePercentage;\n        alpha = computeDecayFactor(distMMin, distMMax, total, iterator);\n    }\n\n    private double computeDecayFactor(int min, int max, double total, int iter) \n    {\n        // Here we use an exponential decay strategy to adjust alpha more smoothly\n        // This can be adapted to different decay schedules as needed\n        double normalizedDecay = (double)(min) / (double)(max);\n        return Math.pow(normalizedDecay, 1.0 / Math.max(total, 1)); // Prevent division by zero\n    }\n\n    // Optional: You could create additional methods for other decay functions like cosine or piecewise if required\n}"
    },
    {
        "sample_order": 6,
        "score": -27591.0,
        "algorithm": "I propose enhancing the `DistAdjustment` class by implementing flexible decay schedules through a strategy pattern and improving numerical stability with smooth transition functions that allow for adaptive adjustments for both exploration and exploitation phases.",
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    int distMMin;\n    int distMMax;\n    int iterator;\n    long ini;\n    double executionMaximumLimit;\n    double alpha = 1;\n    StoppingCriterionType stoppingCriterionType;\n    IdealDist idealDist;\n    DistanceDecayStrategy decayStrategy;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.decayStrategy = new ExponentialDecay(); // Default decay strategy\n    }\n\n    public void setDecayStrategy(DistanceDecayStrategy decayStrategy) {\n        this.decayStrategy = decayStrategy;\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) ini = System.currentTimeMillis();\n        iterator++;\n\n        adjustmentBasedOnCriterion();\n        \n        // Update idealDist based on the alpha value\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    private void adjustmentBasedOnCriterion() {\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = decayStrategy.calculateAlpha(distMMin, distMMax, iterator, executionMaximumLimit);\n                break;\n            case Time:\n                double current = (double) (System.currentTimeMillis() - ini) / 1000;\n                double timePercentage = current / executionMaximumLimit;\n                alpha = decayStrategy.calculateAlpha(distMMin, distMMax, (int)(iterator / timePercentage), executionMaximumLimit);\n                break;\n            default:\n                break;\n        }\n    }\n}\n\n// Strategy interface for distance decay\ninterface DistanceDecayStrategy {\n    double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit);\n}\n\n// Exponential decay implementation\nclass ExponentialDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        return Math.pow((double) distMMin / (double) distMMax, (double) 1 / executionMaximumLimit);\n    }\n}\n\n// Add more decay strategies as needed, e.g., CosineDecay, PiecewiseDecay, etc.\nclass CosineDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        double phase = (double) iterator / executionMaximumLimit;\n        return (1 + Math.cos(Math.PI * phase)) / 2; // Normalized cosine decay\n    }\n}\n\n// Implement a piecewise decay strategy as needed\nclass PiecewiseDecay implements DistanceDecayStrategy {\n    @Override\n    public double calculateAlpha(int distMMin, int distMMax, int iterator, double executionMaximumLimit) {\n        // Custom piecewise decay logic based on certain criteria\n        // Placeholder for illustration\n        if (iterator < executionMaximumLimit / 2) {\n            return Math.pow(((double) distMMin / distMMax), (double) 1 / (executionMaximumLimit / 2));\n        } else {\n            return 1.0; // No decay in the latter half\n        }\n    }\n}"
    }
]