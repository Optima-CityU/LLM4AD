[
    {
        "sample_order": 4,
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    private int distMMin;\n    private int distMMax;\n    private int iterator;\n    private long ini;\n    private final double executionMaximumLimit;\n    private double alpha = 1;\n    private final StoppingCriterionType stoppingCriterionType;\n    private final IdealDist idealDist;\n\n    // DecayFunction interface for adaptive decay schedules\n    interface DecayFunction {\n        double calculateAlpha(int currentIteration, double executionLimit);\n    }\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) {\n            ini = System.currentTimeMillis();\n        }\n\n        iterator++;\n\n        // Calls the appropriate adjustment based on stoppingCriterionType\n        switch (stoppingCriterionType) {\n            case Iteration:\n                alpha = iterationAdjustment();\n                break;\n            case Time:\n                alpha = timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Apply the decay factor and clamp the ideal distance\n        idealDist.idealDist *= alpha;\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Method for iterative adjustment with flexible decay\n    private double iterationAdjustment() {\n        return computeDecayAlpha(distMMin, distMMax, executionMaximumLimit, iterator);\n    }\n\n    // Method for time-based adjustment with flexible decay\n    private double timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        return computeDecayAlpha(distMMin, distMMax, total, 1); // Adapted for time\n    }\n\n    // General method to compute decay alpha for flexibility\n    private double computeDecayAlpha(int dMin, int dMax, double limit, double param) {\n        // Using a piecewise function for nonlinear decay (can be modified to suit needs)\n        if (param < limit) { // Early phase\n            return Math.pow((double) dMin / (double) dMax, 1 / (limit - param + 1)); // Smoother transition\n        } else { // Late phase\n            return 1.0; // Maintain stability\n        }\n    }\n}",
        "score": 27591.0,
        "program": ""
    },
    {
        "sample_order": 10,
        "function": "package DiversityControl;\n\nimport SearchMethod.Config;\nimport SearchMethod.StoppingCriterionType;\n\npublic class DistAdjustment {\n    int distMMin;\n    int distMMax;\n    int iterator;\n    long ini;\n    double executionMaximumLimit;\n    double alpha = 1;\n    StoppingCriterionType stoppingCriterionType;\n    IdealDist idealDist;\n\n    // Define types of decay schedules for flexibility\n    public enum DecayType {\n        LINEAR,\n        EXPONENTIAL,\n        COSINE\n    }\n\n    private DecayType decayType;\n\n    public DistAdjustment(IdealDist idealDist, Config config, double executionMaximumLimit) {\n        this.idealDist = idealDist;\n        this.executionMaximumLimit = executionMaximumLimit;\n        this.distMMin = config.getDMin();\n        this.distMMax = config.getDMax();\n        this.idealDist.idealDist = distMMax;\n        this.stoppingCriterionType = config.getStoppingCriterionType();\n        this.decayType = DecayType.EXPONENTIAL;  // Default decay type\n    }\n\n    // Public method to set the decay type\n    public void setDecayType(DecayType decayType) {\n        this.decayType = decayType;\n    }\n\n    public void distAdjustment() {\n        if (iterator == 0) {\n            ini = System.currentTimeMillis();\n        }\n\n        iterator++;\n\n        switch (stoppingCriterionType) {\n            case Iteration:\n                iterationAdjustment();\n                break;\n            case Time:\n                timeAdjustment();\n                break;\n            default:\n                break;\n        }\n\n        // Apply decay calculation based on the set type\n        applyDecay();\n        \n        // Ensure idealDist remains within defined limits\n        idealDist.idealDist = Math.min(distMMax, Math.max(idealDist.idealDist, distMMin));\n    }\n\n    // Adjust alpha based on the number of iterations\n    private void iterationAdjustment() {\n        alpha = calculateDecay(1.0 - (double) distMMax / distMMin);\n    }\n\n    // Adjust alpha based on time elapsed\n    private void timeAdjustment() {\n        double current = (double) (System.currentTimeMillis() - ini) / 1000;\n        double timePercentage = current / executionMaximumLimit;\n        double total = (double) iterator / timePercentage;\n        alpha = calculateDecay(1.0 - (double) distMMax / distMMin, total);\n    }\n    \n    // Calculate decay using the selected decay type\n    private void applyDecay() {\n        switch (decayType) {\n            case LINEAR:\n                idealDist.idealDist *= alpha;\n                break;\n            case EXPONENTIAL:\n                idealDist.idealDist *= Math.exp(-alpha);\n                break;\n            case COSINE:\n                idealDist.idealDist *= (1 - Math.cos(Math.PI * (iterator / executionMaximumLimit)));\n                break;\n        }\n    }\n\n    // Calculate the decay factor based on the selected decay type\n    private double calculateDecay(double decayRatio) {\n        return Math.pow(decayRatio, 1 / executionMaximumLimit);\n    }\n\n    // Overloaded method for decay calculation with additional parameters for flexibility\n    private double calculateDecay(double decayRatio, double factor) {\n        return Math.pow(decayRatio, 1 / factor);\n    }\n}",
        "score": 28014.0,
        "program": ""
    }
]